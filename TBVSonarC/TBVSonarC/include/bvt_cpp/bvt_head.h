/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/
#ifndef __CPP_BVTHEAD_H__
#define __CPP_BVTHEAD_H__

#include <string>
#include <bvt_cpp/bvt_retval.h>
#include <bvt_cpp/bvt_ping.h>
#include <bvt_cpp/bvt_orientation.h>

namespace BVTSDK
{

/** A head consists of a group of co-planar transducers which are
 * operated simultaneously to produce (ultimately) a single 2d
 * image.  The Head object provides functions to change the 
 * range window as well as produce pings.
 */
class Head
{
public:
	/// Create the object
	Head()
	{ m_ptr = NULL; }

#ifndef DOXY_IGNORE
	Head(BVTHead ptr)
	{ m_ptr = ptr; }

	operator BVTHead()
	{ return m_ptr; }
	operator BVTHead*()
	{ return &m_ptr; }
	operator const BVTHead() const
	{ return m_ptr; }
#endif

	/** ** EXPERIMENTAL **  
	 * Specifies how to handle overlapped beams in specialized sonars.  This function
	 * should only be used under direction from BlueView.
	 * \param opt Option int 
	 */
	RetVal SetOverlapOption(int opt)
	{
		return BVTHead_SetOverlapOption( m_ptr, opt );
	}

	/** ** EXPERIMENTAL **  
	 * Returns current option for how to handle overlapped beams in specialized sonars.
	 */
	int GetOverlapOption()
	{
		return BVTHead_GetOverlapOption( m_ptr );
	}

	/** Retrieve the Head's id.
	 */
	int GetHeadID()
	{
		return BVTHead_GetHeadID( m_ptr );
	}

	/** Retrieves a copy of a the name of the head. The head name is currently
	 * set only at the factory, and is simply "Head" on many sonars. Only special
	 * order sonars with multiple heads are likely to have a different name.<br>
	 * The length of the name has no actual limit, though 80 characters
	 * would seem to be more than enough.
	 * \param buffer buffer to hold the null-terminated string to be passed back 
	 * \param buffer_size total number of characters the passed buffer can hold 
	 */
	RetVal GetHeadName(char buffer[], int buffer_size)
	{
		return BVTHead_GetHeadName( m_ptr, buffer, buffer_size );
	}

	/** Set the range to be acquired.  Before using this function, use function 
	 * BVTHead_GetImageProcessingMethod() and test the return value. If the return 
	 * value is IMAGE_PROCESSING_METHOD_B (1), then the start range must be set to zero.
	 * \param start Start range in meters 
	 * \param stop Stop range in meters 
	 */
	RetVal SetRange(float start, float stop)
	{
		return BVTHead_SetRange( m_ptr, start, stop );
	}

	/** Retrieve the current starting range in meters
	 */
	float GetStartRange()
	{
		return BVTHead_GetStartRange( m_ptr );
	}

	/** Retrieve the current stopping range in meters.
	 */
	float GetStopRange()
	{
		return BVTHead_GetStopRange( m_ptr );
	}

	/** Return the minimum allowable range for this sonar
	 */
	float GetMinimumRange()
	{
		return BVTHead_GetMinimumRange( m_ptr );
	}

	/** Return the maximum allowable range for this sonar
	 */
	float GetMaximumRange()
	{
		return BVTHead_GetMaximumRange( m_ptr );
	}

	static const int FLUID_SALTWATER	= 0;

	static const int FLUID_FRESHWATER	= 1;

	static const int FLUID_OTHER	= 2;

	/** Return the type of water the head is in.  The returned value will correspond to 
	 * one of the FLUID_* constants.
	 */
	int GetFluidType()
	{
		return BVTHead_GetFluidType( m_ptr );
	}

	/** Set the type of water the head is in
	 * \param fluid The fluid type (one of the FLUID_* constants) 
	 */
	RetVal SetFluidType(int fluid)
	{
		return BVTHead_SetFluidType( m_ptr, fluid );
	}

	/** Return the speed of sound in water
	 */
	int GetSoundSpeed()
	{
		return BVTHead_GetSoundSpeed( m_ptr );
	}

	/** Set the speed of sound in water
	 * \param speed Sound speed in water 
	 */
	RetVal SetSoundSpeed(int speed)
	{
		return BVTHead_SetSoundSpeed( m_ptr, speed );
	}

	/** Return the additional analog gain in dB
	 * Note: Most BlueView sonars don't support adjustable gain.
	 */
	float GetGainAdjustment()
	{
		return BVTHead_GetGainAdjustment( m_ptr );
	}

	/** Set the additional analog gain. 
	 * Note: Most BlueView sonars don't support adjustable gain.
	 * \param gain Additional analog gain in dB 
	 */
	RetVal SetGainAdjustment(float gain)
	{
		return BVTHead_SetGainAdjustment( m_ptr, gain );
	}

	/** Return the time variable gain in dB/meter
	 * Note: Most BlueView sonars don't support TVG
	 */
	float GetTVGSlope()
	{
		return BVTHead_GetTVGSlope( m_ptr );
	}

	/** Set the  time variable analog gain. 
	 * Note: Most BlueView sonars don't support TVG
	 * \param tvg Time variable gain in dB/meter 
	 */
	RetVal SetTVGSlope(float tvg)
	{
		return BVTHead_SetTVGSlope( m_ptr, tvg );
	}

	/** Return the center frequency(in Hz) of this head.
	 */
	int GetCenterFreq()
	{
		return BVTHead_GetCenterFreq( m_ptr );
	}

	/** Return the number of pings 'in' this head
	 * A head attached to a file might have more than one ping recorded.  However, a networked sonar
	 * will only have a single ping.
	 */
	int GetPingCount()
	{
		return BVTHead_GetPingCount( m_ptr );
	}

	/** Retrieve a Ping from the Head
	 * If ping_num is less than 0, return the next ping in the file. Otherwise, load the specified ping.  
	 * If the Head is attached to a 'live' sonar (network), then GetPing always acquires a new ping.
	 * \param ping_num The ping number to return 
	 * \param ping The returned Ping object
	 */
	RetVal GetPing(int ping_num, Ping* ping)
	{
		return BVTHead_GetPing( m_ptr, ping_num, *ping );
	}

	/** Write a ping to a file.
	 * \param ping The ping to write out 
	 */
	RetVal PutPing(const Ping& ping)
	{
		return BVTHead_PutPing( m_ptr, ping );
	}

	/** Turn off image processing	
	 */
	static const int RES_OFF	= 0;

	/** Process at low resolution 
	 */
	static const int RES_LOW	= 1;

	/** Process at med resolution 
	 */
	static const int RES_MED	= 2;

	/** Process at high resolution 
	 */
	static const int RES_HIGH	= 3;

	/** Select a good res for the current range automatically 
	 */
	static const int RES_AUTO	= 4;

	/** Set the image processing resolution. The RES_AUTO setting is highly
	 * recommended, as it adapts via a formula according to the stop range,
	 * whereas the other ranges are fixed values, and should only be used
	 * in specialized cases, such as requesting high resolution for longer
	 * distances (which will increase the processing time required to 
	 * create the image). R-Theta images may use either this funtion or
	 * SetRangeResolution(), depending on the degree of control required.
	 * \param res Resolution constant (RES_*)
	 */
	RetVal SetImageRes(int res)
	{
		return BVTHead_SetImageRes( m_ptr, res );
	}

	/** Requests a range resolution for R-Theta images. Also affects the
	 * range resolution for RangeData. Note that the exact range resolution
	 * may not be available, and the closest resolution will be set. The
	 * actual resolution can be obtained by querying the returned image
	 * or RangeData object.
	 * \param resolution_in_meters Range resolution, in meters 
	 */
	RetVal SetRangeResolution(float resolution_in_meters)
	{
		return BVTHead_SetRangeResolution( m_ptr, resolution_in_meters );
	}

	/** Set the requested out image size
	 * The processing code will attempt to process images at the specified size.
	 * However, it doesn't guarantee that the final output will match this size.
	 * NOTE: For R-Theta images, only the width is used, and the image will
	 * be created with that exact width. Height will depend on the range,
	 * and the resolution set. (See SetImageRes() and SetRangeResolution())
	 * \param height The requested height 
	 * \param width The requested width 
	 */
	RetVal SetImageReqSize(int height, int width)
	{
		return BVTHead_SetImageReqSize( m_ptr, height, width );
	}

	/** Set the XY image size
	 * This is a helper function to accompany the Ping's GetImageXY() function.
	 * \param height The requested height 
	 * \param width The requested width 
	 */
	RetVal SetXYImageSize(int height, int width)
	{
		return BVTHead_SetXYImageSize( m_ptr, height, width );
	}

	/** Set the RTheta image width
	 * This is a helper function to accompany the Ping's GetImageRTheta() function.
	 * \param width The requested width 
	 */
	RetVal SetRThetaImageWidth(int width)
	{
		return BVTHead_SetRThetaImageWidth( m_ptr, width );
	}

	/** NOTE: this option is only valid for some sonars, in specific circumstances,
	 * and should only be used on advice from the factory. <br>
	 * By default, beamforming is done on the local system.  If you call this
	 * function with enable=true, the SDK will request that the remote sonar
	 * handle the majority of the beamforming. This operation applies the next 
	 * time GetPing is called. <br>
	 * \param enable Enable/Disable remote beamformer. (using 1 or 0 to enable or disable) 
	 */
	RetVal SetRemoteBeamForming(int enable)
	{
		return BVTHead_SetRemoteBeamForming( m_ptr, enable );
	}

	/** NOTE: this option is only valid for some sonars, in specific circumstances,
	 * and should only be used on advice from the factory. <br>
	 * By default, the sonar sends data suitable for saving to a .son file.  If you 
	 * are not saving files, AND are recieving processed data thru setting one of
	 * the other options, you can call this function with enable=false to reduce the 
	 * amount of network bandwidth needed. . This operation applies the next time GetPing 
	 * is called.
	 * \param enable Enable/Disable raw ping data. (using 1 or 0 to enable or disable) 
	 */
	RetVal SetRawDataSending(int enable)
	{
		return BVTHead_SetRawDataSending( m_ptr, enable );
	}

	/** NOTE: this option is only valid for some sonars, in specific circumstances,
	 * and should only be used on advice from the factory. <br>
	 * By default, image forming is done on the local system. 
	 * If you call this function with en=true, the SDK will request that
	 * the remote sonar handle the image forming. This option is slightly
	 * different than remote beam-forming, with all processing done on
	 * the sonar, and only the complete image sent over the network connection.
	 * This operation applies the next time GetPing is called. <br>
	 * \param enable Enable/Disable remote image forming. (using 1 or 0 to enable or disable) 
	 */
	RetVal SetRemoteImageForming(int enable)
	{
		return BVTHead_SetRemoteImageForming( m_ptr, enable );
	}

	/** Output a cartesian image 
	 */
	static const int IMAGE_XY	= 0;

	/** Output a Range/Theta image 
	 */
	static const int IMAGE_RTHETA	= 1;

	/** Set the type of image created by the BVTPing_GetImage() function.
	 * NOTE: See SetImageReqSize() for important issues regarding image size.
	 * If images are requested with the BVTPing_GetXYImage() or 
	 * BVTPing_GetRThetaImage(), then this function is not needed.
	 * \param type Image type constant (IMAGE_*) 
	 */
	RetVal SetImageType(int type)
	{
		return BVTHead_SetImageType( m_ptr, type );
	}

	/** Process an image with no filtering 
	 */
	static const int IMAGE_FILTERFLAG_NONE	= 0;

	/** Process an image with a 3x3 mean filter 
	 */
	static const int IMAGE_FILTERFLAG_MEAN3X3	= 2;

	/** Process an image with a 9x2 mean filter 
	 */
	static const int IMAGE_FILTERFLAG_MEAN9x2	= 16;

	/** Return the filter flags.  As of this version, if more than one flag is set, only the lowest-valued flag is used.
	 */
	int GetImageFilterFlags()
	{
		return BVTHead_GetImageFilterFlags( m_ptr );
	}

	/** Set the filter flags. As of this version, if more than one flag is set, only the lowest-valued flag is used.
	 * \param flags Image filter flags (bit field) 
	 */
	RetVal SetImageFilterFlags(int flags)
	{
		return BVTHead_SetImageFilterFlags( m_ptr, flags );
	}

	/** ImageCalibrationA and ImageCalibrationB are used and should be set to appropriate values. 
	 */
	static const int IMAGE_PROCESSING_METHOD_A	= 0;

	/** ImageCalibrationA and ImageCalibrationB are not used. 
	 */
	static const int IMAGE_PROCESSING_METHOD_B	= 1;

	/** Inform the user about which type of image processing algorithm is being used.  
	 * The returned value will correspond to one of the IMAGE_PROCESSING_METHOD_* constants.
	 */
	int GetImageProcessingMethod()
	{
		return BVTHead_GetImageProcessingMethod( m_ptr );
	}

	/** Return the current image calibration value A.
	 */
	int GetImageCalibrationA()
	{
		return BVTHead_GetImageCalibrationA( m_ptr );
	}

	/** Set the image calibration value for A.
	 * This function should only be used for older sonars.  Before using this function,
	 * use function BVTHead_GetImageProcessingMethod() and test the return value.  If the return
	 * value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
	 * use this function.
	 * NOTE: These values will be permanently saved on the sonar,
	 * and the sonar's FLASH memory has limited write cycles available,
	 * so this function should not be called often.
	 * \param cal_value Image calibration value 
	 */
	RetVal SetImageCalibrationA(int cal_value)
	{
		return BVTHead_SetImageCalibrationA( m_ptr, cal_value );
	}

	/** Return the current image calibration value B.
	 */
	int GetImageCalibrationB()
	{
		return BVTHead_GetImageCalibrationB( m_ptr );
	}

	/** Set the image calibration value for B.
	 * This function should only be used for older sonars.  Before using this function,
	 * use function BVTHead_GetImageProcessingMethod() and test the return value.  If the return
	 * value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
	 * use this function.
	 * NOTE: These values will be permanently saved on the sonar,
	 * and the sonar's FLASH memory has limited write cycles available,
	 * so this function should not be called often.
	 * \param cal_value Image calibration value 
	 */
	RetVal SetImageCalibrationB(int cal_value)
	{
		return BVTHead_SetImageCalibrationB( m_ptr, cal_value );
	}

	/** This function should only be used for older sonars.  Before using this function,
	 * use function BVTHead_GetImageProcessingMethod() and test the return value.  If the return
	 * value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
	 * use this function.
	 * Starts the AutoImageCalibration process which computes ImageCalibrationA (and ImageCalibrationB, if appropriate).
	 * \param MBSonar Set to 1 if sonar is of type MB, set to 0 for all other sonars 
	 * \param reserved Should always be set to -1. Reserved for future use 
	 */
	RetVal DoAutoImageCalibration(int MBSonar, int reserved)
	{
		return BVTHead_DoAutoImageCalibration( m_ptr, MBSonar, reserved );
	}

	/** AutoImageCalibration has not yet been performed 
	 */
	static const int NOT_COMPUTED	= 0;

	/** AutoImageCalibration is in progress 
	 */
	static const int IN_PROGRESS	= 1;

	/** AutoImageCalibration process completed with valid results 
	 */
	static const int COMPUTED_HFC_VALID	= 2;

	/** AutoImageCalibration process completed with invalid results 
	 */
	static const int COMPUTED_HFC_INVALID	= 3;

	/** This function should only be used for older sonars.  Before using this function,
	 * use function BVTHead_GetImageProcessingMethod() and test the return value.  If the return
	 * value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
	 * use this function.
	 * Returns the state of the AutoImageCalibration processing. 
	 * The returned ImageCalibrationA/B values will be set to -1 for unless the
	 * function's return value is BVTHEAD_COMPUTED_HFC_VALID.
	 * The returned ImageCalibrationB value is only computed for certain sonars and 
	 * will have a value of -1 if not appropriate for the current sonar. 
	 * \param ImageCalibrationA Value computed by the Auto Image Calibration process 
	 * \param ImageCalibrationB Value computed by the Auto Image Calibration process 
	 */
	int GetAutoImageCalibrationStatus(int* ImageCalibrationA, int* ImageCalibrationB)
	{
		return BVTHead_GetAutoImageCalibrationStatus( m_ptr, ImageCalibrationA, ImageCalibrationB );
	}

	/** Sets the intensity value below which data is
	 * considered to be noise. Values above this threshold are included in
	 * the algorithm which attempts to determine the target edge. This is
	 * NOT a simple threshold above which the first value encountered is
	 * considered the target edge. This is the same intensity value returned
	 * in a MagImage, with a range of an unsigned 16-bit integer.
	 * If not set, the default is currently set to 1000. <br>
	 * NOTE: This only applies to specialized BlueView sonars.
	 * \param noise_threshold Threshold below which is considered noise 
	 */
	RetVal SetRangeDataThreshold(unsigned short noise_threshold)
	{
		return BVTHead_SetRangeDataThreshold( m_ptr, noise_threshold );
	}

	/** Set the range at which to start processing range data.
	 * \param start range in meters 
	 */
	RetVal SetTargetStartRange(float start)
	{
		return BVTHead_SetTargetStartRange( m_ptr, start );
	}

	/** By default, the sonar transmits pings.  This function allows the user to 
	 * disable transmit.  This can be useful to get background noise measurements.
	 * Note that this is not implemented on all sonars.
	 * \param enableTx If 0, disable the sonar transmission of pings.
	 */
	RetVal SetTxEnable(int enableTx)
	{
		return BVTHead_SetTxEnable( m_ptr, enableTx );
	}

	/** Stores a copy of the Orientation data with the in the head's MountingOrientation object, so the data
	 * will be saved if the head is saved to a file.
	 * \param orient Orientation data object to copy from 
	 */
	RetVal PutMountingOrientation(const Orientation& orient)
	{
		return BVTHead_PutMountingOrientation( m_ptr, orient );
	}

	/** Retrieves a copy of the MountingOrientation object stored with this head. Note
	 * that the data is copied out of the head into the local Orientation object,
	 * a pointer to internal data is not returned. Thus, the Orientation object
	 * may be used after the head is destroyed.
	 * \param orient Orientation data object to copy the existing Orientation data to 
	 */
	RetVal GetMountingOrientationCopy(Orientation* orient)
	{
		return BVTHead_GetMountingOrientationCopy( m_ptr, *orient );
	}

	/** Stores a copy of the Orientation data with the in the head's MountingOrientation object, so the data
	 * will be saved if the head is saved to a file.
	 * This second (auxillary) Orientation object is optional. 
	 * \param orient Orientation data object to copy from 
	 */
	RetVal PutAuxMountingOrientation(const Orientation& orient)
	{
		return BVTHead_PutAuxMountingOrientation( m_ptr, orient );
	}

	/** Retrieves a copy of the MountingOrientation object stored with this head. Note
	 * that the data is copied out of the head into the local Orientation object,
	 * a pointer to internal data is not returned. Thus, the Orientation object
	 * may be used after the head is destroyed.
	 * This second (auxillary) Orientation object is optional.  Calling this function on an unused auxillary Orientation will return all zeros. 
	 * \param orient Orientation data object to copy the existing Orientation data to 
	 */
	RetVal GetAuxMountingOrientationCopy(Orientation* orient)
	{
		return BVTHead_GetAuxMountingOrientationCopy( m_ptr, *orient );
	}

	static const int MOUNT_UNKNOWN	= 0;

	static const int MOUNT_POLE	= 1;

	static const int MOUNT_TRIPOD	= 2;

	static const int MOUNT_ROV	= 3;

	static const int MOUNT_UUV	= 4;

	static const int MOUNT_OTHER	= 5;

	/** Identifies the general configuration of how this data was collected.
	 * \param type One of the MOUNT_* constants 
	 */
	RetVal SetMountType(int type)
	{
		return BVTHead_SetMountType( m_ptr, type );
	}

	/** Return the general configuration of data collection.  The returned value will correspond to 
	 * one of the MOUNT_* constants.
	 */
	int GetMountType()
	{
		return BVTHead_GetMountType( m_ptr );
	}

	static const int SIDE_UNKNOWN	= 0;

	static const int SIDE_PORT	= 1;

	static const int SIDE_STARBOARD	= 2;

	static const int SIDE_DORSAL	= 3;

	static const int SIDE_VENTRAL	= 4;

	static const int SIDE_BOW	= 5;

	static const int SIDE_STERN	= 6;

	static const int SIDE_OTHER	= 7;

	/** Helps identify how this data was collected.
	 * \param side One of the SIDE_* constants 
	 */
	RetVal SetMountSide(int side)
	{
		return BVTHead_SetMountSide( m_ptr, side );
	}

	/** Return some info about data collection.  The returned value will correspond to 
	 * one of the SIDE_* constants.
	 */
	int GetMountSide()
	{
		return BVTHead_GetMountSide( m_ptr );
	}

	/** This offset is calculated as MRU time - Sonar time;			
	 * \param milliseconds Offset in milliseconds between the MRU's time reading and the Sonar's time reading. 
	 */
	RetVal SetMRUTimeOffset(int milliseconds)
	{
		return BVTHead_SetMRUTimeOffset( m_ptr, milliseconds );
	}

	/** This offset is calculated as MRU time - Sonar time;			
	 */
	int GetMRUTimeOffset()
	{
		return BVTHead_GetMRUTimeOffset( m_ptr );
	}

	/** 
	 * \param bearing Bearing in degrees from pole mount to GPS antenna. 
	 * \param distance Distance in meters from pole mount to GPS antenna. 
	 */
	RetVal SetPoleGPSBearing(float bearing, float distance)
	{
		return BVTHead_SetPoleGPSBearing( m_ptr, bearing, distance );
	}

	/** 
	 * \param bearing Bearing in degrees from pole mount to GPS antenna. 
	 * \param distance Distance in meters from pole mount to GPS antenna. 
	 */
	RetVal GetPoleGPSBearing(float* bearing, float* distance)
	{
		return BVTHead_GetPoleGPSBearing( m_ptr, bearing, distance );
	}

	/** 
	 * \param bearing Bearing in degrees from pole mount to landmark. 
	 */
	RetVal SetPoleLandmarkBearing(float bearing)
	{
		return BVTHead_SetPoleLandmarkBearing( m_ptr, bearing );
	}

	/** Returns bearing in degrees from pole mount to landmark. 
	 */
	float GetPoleLandmarkBearing()
	{
		return BVTHead_GetPoleLandmarkBearing( m_ptr );
	}

	/** This is used in tripod mount situations where the default/baseline/normal/center
	 * position of the Head is not aligned with the tripod-mounted compass's
	 * North direction.
	 * This offset is calculated as MRU time - Sonar time;			
	 * \param offset Offset in degrees from compass North. 
	 */
	RetVal SetHeadingOffset(float offset)
	{
		return BVTHead_SetHeadingOffset( m_ptr, offset );
	}

	/** Returns offset in degrees from compass North. 
	 * This is used in tripod mount situations where the default/baseline/normal/center
	 * position of the Head is not aligned with the tripod-mounted compass's
	 * North direction.
	 */
	float GetHeadingOffset()
	{
		return BVTHead_GetHeadingOffset( m_ptr );
	}

	/** This is used to compute x,y,z offsets driven by the tilt position.
	 * The manufacturer and model strings are limited to a maximum of 79 characters, not counting the terminating null characters.
	 * \param manufacturer Manufacturer of pan/tilt unit e.g. ROS 
	 * \param model pan/tilt model  
	 * \param elbowOffset offset from tilt motor axis to center of sonar 
	 */
	RetVal setPanTiltAttributes(std::string manufacturer, std::string model, float elbowOffset)
	{
		return BVTHead_setPanTiltAttributes( m_ptr, manufacturer.c_str(), model.c_str(), elbowOffset );
	}

	/** Returns the string.
	 */
	const std::string getPanTiltManufacturer()
	{
		return BVTHead_getPanTiltManufacturer( m_ptr );
	}

	/** Returns the string.
	 */
	const std::string getPanTiltModel()
	{
		return BVTHead_getPanTiltModel( m_ptr );
	}

	/** This is used to compute x,y,z offsets driven by the tilt position.
	 */
	float getPanTiltElbowOffset()
	{
		return BVTHead_getPanTiltElbowOffset( m_ptr );
	}

	/** Helper function to retrieve the pan/tilt mount offsets.  
	 * The panRotationOffset and tiltRotationOffset values should be subtracted 
	 * from the X_axis_degrees (pan) and Y_axis_degrees (tilt) parameters 
	 * of the BVTPing_GetPositionerRotations() function to obtain 
	 * the same pan & tilt values displayed during data collection.
	 * If verticalInverted is false(0), then the tilt value obtained in the 
	 * step above must be multiplied by -1.0 to represent real-world tilt values.
	 * \param tiltElbowVerticalOffset in meters 
	 * \param tiltElbowHorizontalOffset in meters 
	 * \param panRotationOffset offset to "home" position 
	 * \param tiltRotationOffset offset to "home" position 
	 * \param verticalInverted either 1 or 0, to indicate true or false, respectively 
	 */
	RetVal GetPanTiltMountOffsets(float* tiltElbowVerticalOffset, float* tiltElbowHorizontalOffset, float* panRotationOffset, float* tiltRotationOffset, int* verticalInverted)
	{
		return BVTHead_GetPanTiltMountOffsets( m_ptr, tiltElbowVerticalOffset, tiltElbowHorizontalOffset, panRotationOffset, tiltRotationOffset, verticalInverted );
	}

	/** Helper function to set the pan/tilt mount offsets.  
	 * The panRotationOffset and tiltRotationOffset values should be subtracted 
	 * from the X_axis_degrees (pan) and Y_axis_degrees (tilt) parameters 
	 * of the BVTPing_GetPositionerRotations() function to obtain 
	 * the same pan & tilt values displayed during data collection.
	 * verticalInverted is set to false(0) if the pan/tilt device has been mounted in an inverted fashion.
	 * \param tiltElbowVerticalOffset in meters 
	 * \param tiltElbowHorizontalOffset in meters 
	 * \param panRotationOffset offset to "home" position 
	 * \param tiltRotationOffset offset to "home" position 
	 * \param verticalInverted either 1 or 0, to indicate true or false, respectively 
	 */
	RetVal SetPanTiltMountOffsets(float tiltElbowVerticalOffset, float tiltElbowHorizontalOffset, float panRotationOffset, float tiltRotationOffset, int verticalInverted)
	{
		return BVTHead_SetPanTiltMountOffsets( m_ptr, tiltElbowVerticalOffset, tiltElbowHorizontalOffset, panRotationOffset, tiltRotationOffset, verticalInverted );
	}


private:
	BVTHead m_ptr;
};
}

#endif
