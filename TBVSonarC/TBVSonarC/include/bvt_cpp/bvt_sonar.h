/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/
#ifndef __CPP_BVTSONAR_H__
#define __CPP_BVTSONAR_H__

#include <string>
#include <bvt_cpp/bvt_retval.h>
#include <bvt_cpp/bvt_sonar.h>
#include <bvt_cpp/bvt_ping.h>
#include <bvt_cpp/bvt_head.h>
#include <bvt_cpp/bvt_navdata.h>
#include <bvt_cpp/bvt_orientation.h>
#include <bvt_cpp/bvt_eventmark.h>

namespace BVTSDK
{

/** The Sonar object is the top level object in the SDK.  A sonar 
 * object embodies communication with a single physical sonar unit,
 * or file.  Each sonar contains several heads, which is where most
 * of the functionality is implemented.  Sonar also provides a
 * function to create new data files using BlueView's .son format.
 */
class Sonar
{
public:
	/// Create the object
	Sonar()
	{ m_ptr = BVTSonar_Create(); }

	/// Destroy the object
	~Sonar()
	{ BVTSonar_Destroy(m_ptr); }

#ifndef DOXY_IGNORE
	Sonar(BVTSonar ptr)
	{ m_ptr = ptr; }

	operator BVTSonar()
	{ return m_ptr; }
	operator BVTSonar*()
	{ return &m_ptr; }
	operator const BVTSonar() const
	{ return m_ptr; }
#endif

	/** Open the sonar type 'type' using the specified parameters.
	 * Allowed types (and parameters):
	 * - FILE <br>
	 * [filename] - Required <br>
	 * - NET <br>
	 * [host] - Connect to the specified host.<br>
	 * \param type The type of sonar to open	
	 * \param type_params Various type-specific parameters 
	 */
	RetVal Open(std::string type, std::string type_params)
	{
		return BVTSonar_Open( m_ptr, type.c_str(), type_params.c_str() );
	}

	/** Create a new data file.
	 * Files are always created by 'cloning' another Sonar
	 * object.  This ensures that the file receives all the
	 * needed setup/configuration data needed to process 
	 * images.
	 * \param file_name The filename of the file to be created 
	 * \param src The Sonar object to clone when creating the file 
	 * \param create_params Parameters for (reserved for future use) 
	 */
	RetVal CreateFile(std::string file_name, const Sonar& src, std::string create_params)
	{
		return BVTSonar_CreateFile( m_ptr, file_name.c_str(), src, create_params.c_str() );
	}

	/** 
	 */
	RetVal GetSerialNumber(char buffer[], int buffer_size)
	{
		return BVTSonar_GetSerialNumber( m_ptr, buffer, buffer_size );
	}

	/** 
	 */
	RetVal GetFirmwareRevision(char buffer[], int buffer_size)
	{
		return BVTSonar_GetFirmwareRevision( m_ptr, buffer, buffer_size );
	}

	/** Gets the size of a file created with CreateFile(). Only works with
	 * file type sonars. A networked sonar will return 0, as will a file
	 * type sonar if there is no open file associated with it.
	 * The return value must be multiplied by 1000 to get the actual
	 * file size in bytes.
	 */
	int GetFileSize()
	{
		return BVTSonar_GetFileSize( m_ptr );
	}

	/** Return the number of time indexed pings in this file.
	 */
	int GetTimeIndexedPingCount()
	{
		return BVTSonar_GetTimeIndexedPingCount( m_ptr );
	}

	/** Retrieve a ping from the file, using the time index.
	 * The Ping will have the same Head parent that it was acquired with.
	 * If this function is called on a "live" sonar (network),
	 * then it always returns the FAILED (1) error.
	 * \param ping_num The ping number to return 
	 * \param ping The returned Ping object
	 */
	RetVal GetTimeIndexedPing(int ping_num, Ping* ping)
	{
		return BVTSonar_GetTimeIndexedPing( m_ptr, ping_num, *ping );
	}

	/** Returns 1 if this is a file that requires indexing each time it's opened. 
	 * Returns 0 if this file does not need reindexing.
	 * Returns -1 otherwise (e.g. this is a networked sonar or invalid sonar object)
	 */
	int NeedsIndexing()
	{
		return BVTSonar_NeedsIndexing( m_ptr );
	}

	/** Retrieve a Head object from the sonar
	 * \param head_num The head number to return 
	 * \param head The returned Head object 
	 */
	RetVal GetHead(int head_num, Head* head)
	{
		return BVTSonar_GetHead( m_ptr, head_num, *head );
	}

	/** Return the number of heads on this sonar.
	 */
	int GetHeadCount()
	{
		return BVTSonar_GetHeadCount( m_ptr );
	}

	/** Retrieves a copy of a short string with the model of the sonar.
	 * At the time of this writing, 20 characters would easily hold all of
	 * the sonar model names.
	 * \param buffer buffer to hold the null-terminated string to be passed back 
	 * \param buffer_size total number of characters the passed buffer can hold 
	 */
	RetVal GetSonarTypeAsString(char buffer[], int buffer_size)
	{
		return BVTSonar_GetSonarTypeAsString( m_ptr, buffer, buffer_size );
	}

	/** Retrieves a copy of the name of the sonar. The name is set only via
	 * the ProViewer application (at least at this time), or at the factory,
	 * and is separate from any BlueView model designations. <br>
	 * The length of the name could be considerably longer than the sonar type,
	 * and there is no actual limit, though 80 characters would seem to be
	 * more than enough.
	 * \param buffer buffer to hold the null-terminated string to be passed back 
	 * \param buffer_size total number of characters the passed buffer can hold 
	 */
	RetVal GetSonarName(char buffer[], int buffer_size)
	{
		return BVTSonar_GetSonarName( m_ptr, buffer, buffer_size );
	}

	/** Return the sonar's internal temperature in degrees Celsius
	 * If the sonar doesn't have a temp sensor this function returns
	 * absolute zero (-273.15)
	 */
	float GetTemperature()
	{
		return BVTSonar_GetTemperature( m_ptr );
	}

	/** Write the object to a file.  Note that this object is not associated with a Ping.
	 * \param nav_data The Navigation data object to write out 
	 */
	RetVal PutNavData(const NavData& nav_data)
	{
		return BVTSonar_PutNavData( m_ptr, nav_data );
	}

	/** Returns the number of NavData objects in this file.  This count does not include any NavData objects that were written to the file as part of a Ping.
	 */
	int GetNavDataCount()
	{
		return BVTSonar_GetNavDataCount( m_ptr );
	}

	/** Retrieve a NavData object from the file.
	 * The index is zero-based, that is, if GetNavDataCount() returned a value of 3, then valid indices are 0, 1, and 2.
	 * \param index index of NavData to return 
	 * \param nav_data The returned NavData object
	 */
	RetVal GetNavDataCopy(int index, NavData* nav_data)
	{
		return BVTSonar_GetNavDataCopy( m_ptr, index, *nav_data );
	}

	/** Write the object to a file.  Note that this object is not associated with a Ping.
	 * \param orient The Orientation data object to write out 
	 */
	RetVal PutOrientation(const Orientation& orient)
	{
		return BVTSonar_PutOrientation( m_ptr, orient );
	}

	/** Returns the number of Orientation objects in this file.  This count does not include any Orientation objects that were written to the file as part of a Ping or a Head.
	 */
	int GetOrientationCount()
	{
		return BVTSonar_GetOrientationCount( m_ptr );
	}

	/** Retrieve a Orientation object from the file.
	 * The index is zero-based, that is, if GetlOrientationCount() returned a value of 3, then valid indices are 0, 1, and 2.
	 * \param index index of Orientation to return 
	 * \param orient The returned Orientation object
	 */
	RetVal GetOrientationCopy(int index, Orientation* orient)
	{
		return BVTSonar_GetOrientationCopy( m_ptr, index, *orient );
	}

	/** Creates and writes an EventMark to the current file.
	 * The key string contains arbitrary user-defined text.  The maximum length is 80 characters.
	 * The text string contains arbitrary user-defined text.  The maximum length is 512 characters.
	 * These strings provide a means to store raw data strings from various sensors such as a GPS or compass.
	 * The Key string would be used to identify the device, e.g. "GPS", and the data string ("sentence") from 
	 * the device would be stored in the Text string.
	 * Note that the EventMark is not associated with a Ping.
	 * \param key null-terminated character string 
	 * \param text null-terminated character string 
	 */
	RetVal PutEventMark(std::string key, std::string text)
	{
		return BVTSonar_PutEventMark( m_ptr, key.c_str(), text.c_str() );
	}

	/** Returns the number of EventMark objects in this file.  
	 */
	int GetEventMarkCount()
	{
		return BVTSonar_GetEventMarkCount( m_ptr );
	}

	/** Retrieve an EventMark object from the file.
	 * The index is zero-based, that is, if getTotalEventMarks() returned a value of 3, then valid indices are 0, 1, and 2.
	 * \param index index of EventMark to return 
	 */
	RetVal GetEventMarkCopy(int index, EventMark* em)
	{
		return BVTSonar_GetEventMarkCopy( m_ptr, index, *em );
	}

	/** This function will enable (true) or disable (false) the external trigger feature
	 * of the sonar.  The external triggering must be present on the sonar for this
	 * function to work other wise it will throw return value of 0x18000 = TRIGGER_NOT_PRESENT
	 * The delay in miliseconds can not be larger than 100 miliseconds.  If the value is greater than 
	 * 100 miliseconds the value will be truncated to 100 miliseconds.
	 * \param enable true or false whether external trigge is enabled
	 * \param delay_miliseconds delay in miliseconds from when trigger detected to when ping initiated
	 */
	RetVal SetExternalTrigger(bool enable, unsigned int delay_miliseconds)
	{
		return BVTSonar_SetExternalTrigger( m_ptr, enable, delay_miliseconds );
	}


private:
	BVTSonar m_ptr;

	/// Prevent this object from being coppied
	Sonar(const Sonar&);
	Sonar&operator=(const Sonar&);
};
}

#endif
