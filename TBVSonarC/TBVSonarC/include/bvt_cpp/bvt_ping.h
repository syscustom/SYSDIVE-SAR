/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/
#ifndef __CPP_BVTPING_H__
#define __CPP_BVTPING_H__

#include <string>
#include <bvt_cpp/bvt_retval.h>
#include <bvt_cpp/bvt_magimage.h>
#include <bvt_cpp/bvt_rangedata.h>
#include <bvt_cpp/bvt_navdata.h>
#include <bvt_cpp/bvt_orientation.h>

namespace BVTSDK
{

/** As its name implies, the Ping object represents the return from 
 * a single ping on a particular head. GetImage is the most important
 * function in Ping as it does whatever processing is necessary to
 * convert the ping to an image.  <br>
 * Each ping may have a video frame associated with it, and saved in
 * the same file. These images are typically from a video camera
 * mounted near the sonar, such as on a ROV. <br>
 * Each ping may also store navigation data to indicate the position
 * and orientation of the vehicle at the time of the ping. <br>
 * A ping is essentially a container for data. As such, after you get
 * a ping from the head and extract the data (or save it to a file),
 * it is necessary to destroy the ping object to free up memory.
 * In the future the Ping object will expose additional information
 * about the ping, such as the orientation of the head when it was
 * generated.
 */
class Ping
{
public:
	/// Create the object
	Ping()
	{ m_ptr = NULL; }

	/// Destroy the object
	~Ping()
	{ BVTPing_Destroy(m_ptr); }

#ifndef DOXY_IGNORE
	Ping(BVTPing ptr)
	{ m_ptr = ptr; }

	operator BVTPing()
	{ return m_ptr; }
	operator BVTPing*()
	{ return &m_ptr; }
	operator const BVTPing() const
	{ return m_ptr; }
#endif

	/** Return the ping number.
	 * Ping numbers only have meaning if the ping came from a file.
	 */
	int GetPingNumber()
	{
		return BVTPing_GetPingNumber( m_ptr );
	}

	/** Return the head number this ping was captured, or saved with.
	 */
	int GetHeadNumber()
	{
		return BVTPing_GetHeadNumber( m_ptr );
	}

	/** Return the ping's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
	 * Pings are timestamped using a standard UNIX time stamp. This is 
	 * a similar value to that returned by the time() C standard library 
	 * function. In fact, the only difference is the addition of fractional seconds.
	 */
	double GetTimestamp()
	{
		return BVTPing_GetTimestamp( m_ptr );
	}

	/** Return the ping's timestamp's offset in seconds from UTC time.  Add this value to
	 * that returned by GetTimestamp() to obtain UTC time.
	 */
	int GetTimeZoneOffset()
	{
		return BVTPing_GetTimeZoneOffset( m_ptr );
	}

	/** Set the ping's internal time stamp.  See GetTimestamp() for more information. 
	 * Note: BlueView strongly recommends that users NOT directly set the time stamp as 
	 * it is set internally when the ping is actually initiated.  If you are trying to 
	 * synchronize two systems, it is far better to simply make sure that the system
	 * clocks are synchronized, as the ping timestamp is created from the 
	 * PC's internal clock. Network Time Protocol and GPS sources provide highly 
	 * accurate ways to accomplish this.
	 * \param sec Timestamp in seconds since 00:00:00 UTC, January 1, 1970 
	 */
	RetVal SetTimestamp(double sec)
	{
		return BVTPing_SetTimestamp( m_ptr, sec );
	}

	/** Set the ping's time zone offset in seconds from UTC time.
	 * \param timeZoneOffset The timestamp's offset in seconds from UTC time. 
	 */
	RetVal SetTimeZoneOffset(int timeZoneOffset)
	{
		return BVTPing_SetTimeZoneOffset( m_ptr, timeZoneOffset );
	}

	/** Retrieve an image of this ping, according to the parameters set
	 * in the head used to get this ping. See Head and MagImage documentation
	 * for more details.
	 * \param img Output image 
	 */
	RetVal GetImage(MagImage* img)
	{
		return BVTPing_GetImage( m_ptr, *img );
	}

	/** Retrieve an XY-format image of this ping, according to the parameters set
	 * in the head used to get this ping. Use BVTHead_SetImageSizeXY() to set the size for this image.
	 * See Head and MagImage documentation for more details.
	 * \param img Output image 
	 */
	RetVal GetImageXY(MagImage* img)
	{
		return BVTPing_GetImageXY( m_ptr, *img );
	}

	/** Retrieve an RTheta-format image of this ping, according to the parameters set
	 * in the head used to get this ping. Use BVTHead_SetImageWidthRTheta() to set the size for this image.
	 * See Head and MagImage documentation for more details.
	 * \param img Output image 
	 */
	RetVal GetImageRTheta(MagImage* img)
	{
		return BVTPing_GetImageRTheta( m_ptr, *img );
	}

	/** ** EXPERIMENTAL ** See RangeData class for more details, and the
	 * Head's SetRangeDataThreshold function.  We recommend setting the Head's image filter to IMAGE_FILTERFLAG_MEAN9X2
	 * NOTE: This only applies to specialized BlueView sonars.
	 * \param data set of ranges at angles for this ping 
	 */
	RetVal GetRangeData(RangeData* data)
	{
		return BVTPing_GetRangeData( m_ptr, *data );
	}

	/** Retrieves a copy of the navigation data stored with this ping. Note
	 * that the data is copied out of the ping into the local NavData object,
	 * a pointer to internal data is not returned. Thus, the NavData object
	 * may be used after the Ping is destroyed.
	 */
	RetVal GetNavDataCopy(NavData* nav_data)
	{
		return BVTPing_GetNavDataCopy( m_ptr, *nav_data );
	}

	/** Stores a copy of the navigation data with the other ping data, so the data
	 * will be saved if the ping is saved to a file.
	 */
	RetVal PutNavData(const NavData& nav_data)
	{
		return BVTPing_PutNavData( m_ptr, nav_data );
	}

	/** Video frame is raw RGB (RGBRGB...) 
	 */
	static const int VIDEO_RGB	= 0;

	/** Video frame is a JPEG image 
	 */
	static const int VIDEO_JPEG	= 1;

	/** Returns the video frame associated with this ping.
	 * The video frame may be in any of the supported image formats.
	 * Some image formats may already contain parameters such as height
	 * and width (and more), but valid pointers must be passed in anyway.
	 * The same pointer can be passed in for multiple parameters, if
	 * those parameters will not be used. However, they are provided both
	 * for formats which do not have embedded size information, and so that
	 * the display window may be created and/or sized without parsing
	 * the image data.<br>
	 * NOTE: This function will return BVT_NO_VIDEO_FRAME if there
	 * is no video frame stored for the ping. <br>
	 * WARNING: The data buffer must NOT be accessed after the ping object is destroyed,
	 * as the pointer will no longer point to valid data and will likely crash your application!
	 * So copy off the data before destroying the Ping object. <br>
	 * The single value pointers must be pointers to allocated data, not just
	 * pointer types. For example:<br>
	 * int height, width, length, type, retval;<br>
	 * int * frame_ptr;<br>
	 * retval = GetVideoFrame( frame_ptr, &height, &width, &length, &type );<br>
	 * \param frame Pointer to a pointer to the image data to be returned 
	 * \param height Pointer to return the uncompressed height of the image, in pixels 
	 * \param width Pointer to return the uncompressed width of the image, in pixels 
	 * \param length Pointer to return the actual size of the data buffer returned, in bytes, which may include additional metadata for some image types 
	 * \param type pointer to return the type of image returned: FRAME_RGB or FRAME_JPEG 
	 */
	RetVal GetVideoFrame(unsigned char** frame, int* height, int* width, int* length, int* type)
	{
		return BVTPing_GetVideoFrame( m_ptr, frame, height, width, length, type );
	}

	/** Store a JPEG image to save with this ping.
	 * Note that the height and width values will simply be stored and
	 * available to read when the frame is retrieved. These have no effect
	 * on the actual image size (the image will not be resized).
	 * The length however is very important, as it determines how far from
	 * the passed image pointer data will be read. An incorrect length could
	 * result in an application crash.
	 * \param frame Pointer to a single video frame
	 * \param height Uncompressed height of the image, in pixels 
	 * \param width Uncompressed width of the image, in pixels 
	 * \param length Actual number of bytes being passed in 
	 */
	RetVal PutVideoFrameJPEG(const unsigned char* frame, int height, int width, int length)
	{
		return BVTPing_PutVideoFrameJPEG( m_ptr, frame, height, width, length );
	}

	/** Stores a copy of the per ping Positioner Orientation data in the ping, so the data
	 * will be saved if the ping is saved to a file. This orientation object represents
	 * the dynamic position of the head as it is moved via a positioner. Other orientation
	 * information will be needed to determine the absolute position of the head relative
	 * to a larger coordinate system (i.e. the vessel). NOTE: the X rotation represents
	 * side to side panning, and Y rotation represents vertical tilt. (which might be opposite
	 * from previous SDKs; though the older files will be translated to the new convention.)
	 * \param orient Orientation data object to copy from 
	 */
	RetVal PutPositionerOrientation(const Orientation& orient)
	{
		return BVTPing_PutPositionerOrientation( m_ptr, orient );
	}

	/** Retrieves a copy of the per ping Positioner Orientation data which was stored with this ping.,
	 * Note that the data is copied out of the ping into the local Orientation object,
	 * a pointer to internal data is not returned. Thus, the Orientation object
	 * may be used after the Ping is destroyed. (see PutPositionerOrientation, above, for more
	 * information on the meaning of the PositionerOrientation data)
	 * \param orient Orientation data object to copy the existing Orientation data to 
	 */
	RetVal GetPositionerOrientationCopy(Orientation* orient)
	{
		return BVTPing_GetPositionerOrientationCopy( m_ptr, *orient );
	}

	/** Simplified function to set just the rotations from the Ping's PositionerOrientation object.
	 * The offsets and calibration values will be zero. The source and target frames will be set to
	 * OR_POSITIONER and OR_HEAD, respectively.
	 * This function is most useful when only pan/tilt values are available and needed.
	 * See the PutPositionerOrientation() documentation for more details.
	 * \param X_axis_degrees pan axis rotation 
	 * \param Y_axis_degrees tilt axis rotation 
	 * \param Z_axis_degrees not currently used 
	 */
	RetVal SetPositionerRotations(double X_axis_degrees, double Y_axis_degrees, double Z_axis_degrees)
	{
		return BVTPing_SetPositionerRotations( m_ptr, X_axis_degrees, Y_axis_degrees, Z_axis_degrees );
	}

	/** Simplified function to get just the rotations from the Ping's PositionerOrientation object.
	 * \param X_axis_degrees pan axis rotation 
	 * \param Y_axis_degrees tilt axis rotation 
	 * \param Z_axis_degrees not currently used 
	 */
	RetVal GetPositionerRotations(double* X_axis_degrees, double* Y_axis_degrees, double* Z_axis_degrees)
	{
		return BVTPing_GetPositionerRotations( m_ptr, X_axis_degrees, Y_axis_degrees, Z_axis_degrees );
	}

	/** Get the pitch angle, in floating point degrees. Bow up is positive.
	 * Some BlueView sonar have an internal tilt sensor that is capable of reporting
	 * the pitch angle, with respect to gravity.  If the sonar doesn't have the sensor,
	 * this function always returns 0.
	 */
	float GetSonarPitchAngle()
	{
		return BVTPing_GetSonarPitchAngle( m_ptr );
	}

	/** Get the roll angle, in floating point degrees. Port side up is positive.
	 * Some BlueView sonar have an internal tilt sensor that is capable of reporting
	 * the roll angle, with respect to gravity.  If the sonar doesn't have the sensor,
	 * this function always returns 0.
	 */
	float GetSonarRollAngle()
	{
		return BVTPing_GetSonarRollAngle( m_ptr );
	}


private:
	BVTPing m_ptr;

	/// Prevent this object from being coppied
	Ping(const Ping&);
	Ping&operator=(const Ping&);
};
}

#endif
